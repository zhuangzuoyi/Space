<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哈拎</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http:://halin.xyz/"/>
  <updated>2019-09-08T15:55:54.550Z</updated>
  <id>http:://halin.xyz/</id>
  
  <author>
    <name>哈拎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>玩转GD32V（五）：尝试使用Embedded Studio开发GD32V</title>
    <link href="http:://halin.xyz/%E7%8E%A9%E8%BD%ACGD32V%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8Embedded-Studio%E5%BC%80%E5%8F%91GD32V.html"/>
    <id>http:://halin.xyz/玩转GD32V（五）：尝试使用Embedded-Studio开发GD32V.html</id>
    <published>2019-09-07T16:31:32.000Z</published>
    <updated>2019-09-08T15:55:54.550Z</updated>
    
    <content type="html"><![CDATA[<p>Embedded Studio是SEGGER开发的一款用于嵌入式开发的IDE，从SEGGER网站上看到Embedded Studio有ARM版本也有RISC-V版本，也就是说Embedded Studio支持ARM跟RISC-V。RISC-V版本已经支持GD32V了。Embedded Studio可以从SEGGER免费下载。</p><h4 id="安装GD32V1xx-CPU-Support-Package"><a href="#安装GD32V1xx-CPU-Support-Package" class="headerlink" title="安装GD32V1xx CPU Support Package"></a>安装GD32V1xx CPU Support Package</h4><p>安装完Embedded Studio后，打开Embedded Studio，在创建工程前先安装GD32V的软件包，在菜单栏中选择Tools/Package Manager,如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/Package_manager.png" alt></p><p>安装方法如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/install_package.gif" alt></p><h4 id="创建GD32V工程"><a href="#创建GD32V工程" class="headerlink" title="创建GD32V工程"></a>创建GD32V工程</h4><p>在菜单栏中选择<strong>File–&gt;New Project</strong>创建工程，打开创建工程窗口后，下拉滚动条到GigaDevice部分，选择<strong>A C/C++ executable for GigaDevice GD32VF1xx</strong> ，然后选择工程路径并命名，如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/create_project.png" alt></p><p>然后选择芯片型号：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/select_mcu.png" alt></p><p>下一步，因为我手上的J-link不支持GD32V，所以这里不用SEGGER_RTT功能，不选择RTT-Files，如下图：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/select_file.png" alt></p><p>下一步后，点击Finish，创建完成。工程总包含的文件几main文件的内容如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/first_project.png" alt></p><h4 id="工程中默认的文件"><a href="#工程中默认的文件" class="headerlink" title="工程中默认的文件"></a>工程中默认的文件</h4><p>该工程目录如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/file_of_project.png" alt></p><p>其中GD32VFxx目录分别有3个文件夹：Device、Scripts、Source。</p><ul><li><p>Device</p><p>有个Include目录，该目录下的文件如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/device_include.png" alt></p></li></ul><p>里面是头文件，有一些应该是GD32V外设库的头文件，可是找不到相关库的.c文件，</p><p>Device下还有个Source文件夹，该文件夹内文件如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/device_source.png" alt></p><ul><li><p>Scripts</p><p>该目录下有个js文件：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/Scripts.png" alt></p></li></ul><p>还不清楚该文件的作用</p><ul><li><p>Source</p><p>该目录下有个<strong>.s</strong>文件：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/sorce.png" alt></p></li></ul><p>从名字上看应该是GD32V的启动文件</p><h4 id="使用外设库"><a href="#使用外设库" class="headerlink" title="使用外设库"></a>使用外设库</h4><p>​    虽然在工程目录下找到一些外设库的头文件，可是在工程目录下跟Embedded Studio安装目录下没找到GD32V外设库文件。就算在我的电脑上全盘搜索也没找到，GD32V给出了用户手册，虽然可以根据手册把GD32V用起来，太费劲了，好在兆易创新提供了库：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/std_lib.png" alt></p><p>下载下来解压后如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/detail_std.png" alt></p><p>把Firmware下的GD32VF103_standard_peripheral拷贝到该工程目录，然后在工程中添加存放外设库的文件夹：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/create_std_folder.png" alt><br>在GD32VF103_standard_peripheral下的source跟include分别添加所需外设的库文件及头文件就可以使用该外设了。</p><h4 id="测试GD32V的usart输出功能"><a href="#测试GD32V的usart输出功能" class="headerlink" title="测试GD32V的usart输出功能"></a>测试GD32V的usart输出功能</h4><p>之前在使用Nuclei Studio的时候成功的使用了GD32V的GPIO，这次尝试下GD32V的usart，下载下来的外设库中有usart发送的例程，参考了该例程的usart初始化，做了个简单的发送程序，首先添加相关库文件，分别添加gpio、时钟、uart库文件：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/add_std_file.png" alt></p><p>main.c中的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;gd32vf103.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void send_char(uint8_t ch)</span><br><span class="line">&#123;</span><br><span class="line">    usart_data_transmit(USART0, ch );</span><br><span class="line">    while ( usart_flag_get(USART0, USART_FLAG_TBE)== RESET)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send_str(uint8_t *str)</span><br><span class="line">&#123;</span><br><span class="line">  while(*str !=&apos;\0&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">  send_char(*str);</span><br><span class="line">  str++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*!</span><br><span class="line">    \brief      main function</span><br><span class="line">    \param[in]  none</span><br><span class="line">    \param[out] none</span><br><span class="line">    \retval     none</span><br><span class="line">*/</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* enable GPIO clock */</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line"></span><br><span class="line">    /* enable USART clock */</span><br><span class="line">    rcu_periph_clock_enable(RCU_USART0);</span><br><span class="line"></span><br><span class="line">    /* connect port to USARTx_Tx */</span><br><span class="line">    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);</span><br><span class="line"></span><br><span class="line">    /* connect port to USARTx_Rx */</span><br><span class="line">    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_10);</span><br><span class="line"></span><br><span class="line">    /* USART configure */</span><br><span class="line">    usart_deinit(USART0);</span><br><span class="line">    usart_baudrate_set(USART0, 115200U);</span><br><span class="line">    usart_word_length_set(USART0, USART_WL_8BIT);</span><br><span class="line">    usart_stop_bit_set(USART0, USART_STB_1BIT);</span><br><span class="line">    usart_parity_config(USART0, USART_PM_NONE);</span><br><span class="line">    usart_hardware_flow_rts_config(USART0, USART_RTS_DISABLE);</span><br><span class="line">    usart_hardware_flow_cts_config(USART0, USART_CTS_DISABLE);</span><br><span class="line">    usart_receive_config(USART0, USART_RECEIVE_ENABLE);</span><br><span class="line">    usart_transmit_config(USART0, USART_TRANSMIT_ENABLE);</span><br><span class="line">    usart_enable(USART0);</span><br><span class="line"></span><br><span class="line">    send_str(&quot;Hello This is GD32V \n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译，编译成功如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/build_success.png" alt></p><p>由于Embedded Studio只支持J-link跟GDB server，为了快速验证该工程能不能用，用ISP方式下载，下载完运行如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/result.png" alt><br>在串口调试助手中可以看到板子成功的输出了Hello This is GD32V。成功使用Embedded Studio</p><h4 id="这次使用Embedded-Studio碰到如下问题"><a href="#这次使用Embedded-Studio碰到如下问题" class="headerlink" title="这次使用Embedded Studio碰到如下问题"></a>这次使用Embedded Studio碰到如下问题</h4><ul><li>Embedded Studio好像是对个人免费，对编译出来的固件大小还没有限制，不过就是有时候会弹出如下对话框，只要点击Continue就可以继续使用了。用起来也感觉比Nuclei Studio好用多了。</li></ul><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/commercial.png" alt></p><ul><li>我这次创建的工程编译生成的固件默认是没有生成HEX文件，要生成HEX文件的话，可以在下面的选项设置：</li></ul><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/es/create_hex.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Embedded Studio是SEGGER开发的一款用于嵌入式开发的IDE，从SEGGER网站上看到Embedded Studio有ARM版本也有RISC-V版本，也就是说Embedded Studio支持ARM跟RISC-V。RISC-V版本已经支持GD32V了。Emb
      
    
    </summary>
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/categories/GD32V-RISC-V/"/>
    
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/tags/GD32V-RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>玩转GD32V（四）：给GD32V烧录程序</title>
    <link href="http:://halin.xyz/%E7%8E%A9%E8%BD%ACGD32V%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%99GD32V%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F.html"/>
    <id>http:://halin.xyz/玩转GD32V（四）：给GD32V烧录程序.html</id>
    <published>2019-09-06T16:19:23.000Z</published>
    <updated>2019-09-07T16:05:36.364Z</updated>
    
    <content type="html"><![CDATA[<p>先前已经成功使用Nuclei Studio编译出了GD32V的程序，现在尝试下怎么在不使用Nuclei Studio下载的情况下，怎么把我编译出来的固件烧进GD32V，我手上的板子是GD32VF103C-START，如下图：<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/01.jpg?x-oss-process=style/add_shuiying" alt></p><p>板子上有GD-link，有USB转TTL连接到GD32V的usart0，还引出了GD32V的USB接口。可以很方便地尝试3种方法，分别是：</p><ul><li>使用GD-Link下载</li><li>使用串口ISP下载</li><li>使用DFU下载</li></ul><h4 id="GD-Link下载"><a href="#GD-Link下载" class="headerlink" title="GD-Link下载"></a>GD-Link下载</h4><p>先看下GD32V的方框图<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/jtag.png?x-oss-process=style/add_shuiying" alt><br>从GD32V的方框图可以看到，GD32V支持JTAG接口，我的板子上有板载GD-Link，可以尝试下用板载GD-Link的JTAG功能给GD32V下载程序。</p><p>首先下载GD-Link烧录工具GigaDevice GD-Link Programmer，我是在<a href="http://gd32mcu.21ic.com/documents" target="_blank" rel="noopener">http://gd32mcu.21ic.com/documents</a>找到的，如下图：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/GD-Link%20Programer.png?x-oss-process=style/add_shuiying" alt></p><p>​ 下载下来，解压后如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/GD-Link%20Programer_file.png?x-oss-process=style/add_shuiying" alt></p><p>首先把板子上的GD-Link接口连接到电脑上，然后打开GD-Link Programmer.exe，首先把Device Interface设置为JTAG，然后连接板子，具体操作如下：<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/gd_halin.gif" alt></p><p>尝试后发现，下载选项无法使用，有可能是半载GD-Link功能受限无法使用下载功能（尝试过程中有提示），也可能是我哪里操作不对。</p><h4 id="使用ISP下载"><a href="#使用ISP下载" class="headerlink" title="使用ISP下载"></a>使用ISP下载</h4><p>下载ISP烧录工具GigaDevice MCU ISP Programmer，同样可以在<a href="http://gd32mcu.21ic.com/documents" target="_blank" rel="noopener">http://gd32mcu.21ic.com/documents</a>找到：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/isp_programer.png?x-oss-process=style/add_shuiying" alt></p><p>首先设置下板子的跳线，把BOOTO拉高，BOOT1拉低，分别设置板子的JP1、JP4，如下图。把GD32V设置为Boot from system memory模式。把USB转TTL连上电脑，然后插上GD-Link用来供电。</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/boot.png?x-oss-process=style/add_shuiying" alt></p><p>然后打开<strong>GigaDevice MCU ISP Programmer.exe</strong>，具体操作如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/isp_halin.gif" alt></p><p>结果显示可以成功使用ISP给GD32V下载程序。</p><h4 id="DFU下载"><a href="#DFU下载" class="headerlink" title="DFU下载"></a>DFU下载</h4><p>首先下载DFU烧录工具GD32 MCU Dfu Tool工具，同样是在<a href="http://gd32mcu.21ic.com/documents" target="_blank" rel="noopener">http://gd32mcu.21ic.com/documents</a>找到：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/dfu_download.png?x-oss-process=style/add_shuiying" alt></p><p>下载下来解压后如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/file_of_dfu.png?x-oss-process=style/add_shuiying" alt></p><p>里面包含了Dfu下载工具，跟GD32 Dfu 设备驱动。</p><p>跟ISP一样，首先把GD32V设置为<strong>Boot from system memory</strong>，把GD32V的USB连上电脑，然后插上GD-Link用来供电。首先需要安装GD32 Dfu的驱动，然后打开GD32 MCU Dfu Tool.exe，具体操作如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/dl/dfu.gif" alt></p><p>结果显示可以成功使用DFU给GD32V下载程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先前已经成功使用Nuclei Studio编译出了GD32V的程序，现在尝试下怎么在不使用Nuclei Studio下载的情况下，怎么把我编译出来的固件烧进GD32V，我手上的板子是GD32VF103C-START，如下图：&lt;br&gt;&lt;img src=&quot;http://hali
      
    
    </summary>
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/categories/GD32V-RISC-V/"/>
    
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/tags/GD32V-RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>玩转GD32V（三）：尝试使用Nuclei Studio开发GD32V</title>
    <link href="http:://halin.xyz/%E7%8E%A9%E8%BD%ACGD32V%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8Nuclei-Studio%E5%BC%80%E5%8F%91GD32V.html"/>
    <id>http:://halin.xyz/玩转GD32V（三）：尝试使用Nuclei-Studio开发GD32V.html</id>
    <published>2019-09-04T15:38:23.000Z</published>
    <updated>2019-09-05T16:02:52.612Z</updated>
    
    <content type="html"><![CDATA[<p>从<a href="https://mp.weixin.qq.com/s/QgenqNZlTb1T4HTS9brYiQ" target="_blank" rel="noopener">GD32V——首颗RISC-V内核32位通用MCU</a>了解到Nuclei Studio支持GD32V，Nuclei Studio是芯来科技基于Eclipse开发的一款支持RISC-V的IDE。这里尝试下使用Nuclei Studio来开发GD32V。<br>Nuclei Studio可以从芯来科技官网上找到，也可以在<a href="http://gd32mcu.21ic.com/documents" target="_blank" rel="noopener">http://gd32mcu.21ic.com/documents</a>找到，如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/source.png?x-oss-process=style/add_shuiying" alt></p><p>其中<strong>Nuclei Studio集成开发环境</strong>的两个链接都指向了芯来科技的<a href="https://www.nucleisys.com/download.php" target="_blank" rel="noopener">下载中心</a>：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/xinlai_download.png?x-oss-process=style/add_shuiying" alt></p><p><strong>Nuclei Studio集成开发环境使用说明文档</strong>两个链接都指向了：<a href="https://wshelloworld.github.io/mybook.github.io/IDE_Pages/1.html" target="_blank" rel="noopener">使用NucleiStudio IDE开发GD32VF103的工程</a>，里面说了如何使用<strong>Nuclei Studio</strong>开发GD32V软件。</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/doc_for_nuclei.png?x-oss-process=style/add_shuiying" alt></p><p>进入到芯来科技的<a href="https://www.nucleisys.com/download.php" target="_blank" rel="noopener">下载中心</a>后，把Nuclei Studio下载下来。下载下来是个压缩文件，加压后如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/root_of_nuclei.png?x-oss-process=style/add_shuiying" alt></p><p>里面有两个文件夹、3个文件。其中NucleiStudio就是该IDE所在目录：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/eclipse.png?x-oss-process=style/add_shuiying" alt></p><p><strong>ToolChain</strong>目录下是开发GD32V所需的工具：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/tools.png?x-oss-process=style/add_shuiying" alt></p><p>Build Tools目录存放了编译时用到的一些工具，OpenOCD是调试是需要用到的，RISC-V Embedded GCC是编译器。</p><p>3个文件中，有一个是JDK安装包，因为eclipse是Java开发的，需要安装JDK，还有个串口调试工具<strong>UartAssist.exe</strong>，<strong>HBird_Driver.exe</strong>不确定是什么，不过从名字上看，是某个硬件的驱动。</p><p>​    这里按照教程<a href="https://wshelloworld.github.io/mybook.github.io/IDE_Pages/1.html" target="_blank" rel="noopener">使用NucleiStudio IDE开发GD32VF103的工程</a>来一步一步创建GD32V的工程，首先打开NucleiStudio，出现如下启动界面：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/first.png?x-oss-process=style/add_shuiying" alt></p><p>然后<strong>建立Workspace</strong>，进入了NucleiStudio的Welcome界面：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/opened.png?x-oss-process=style/add_shuiying" alt></p><p>在菜单栏中，点击File-&gt;New-&gt;C/C++ Project：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/creating.png?x-oss-process=style/add_shuiying" alt></p><p>弹出如下界面：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/C%20project.png?x-oss-process=style/add_shuiying" alt></p><p>选择<strong>C Managed Build</strong>，然后点击Next，给工程命名为<strong>gd32v_01</strong>，工程类型选择GigaDevice RISC-V C Project，如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/named.png?x-oss-process=style/add_shuiying" alt></p><p>然后下一步，选择IC：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/select_mcu.png?x-oss-process=style/add_shuiying" alt></p><p>然后设置编译器路径，编译器为RISC-V Embedded GCC，在目录<strong>NucleiStudio_IDE_201908\ToolChain\RISC-V Embedded GCC</strong>，即添加目录<strong>NucleiStudio_IDE_201908\ToolChain\RISC-V Embedded GCC\8.2.0-2.2-20190521-0004\bin</strong>：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/set_gcc.png?x-oss-process=style/add_shuiying" alt></p><p>然后就建立成功：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/project.png?x-oss-process=style/add_shuiying" alt></p><p>接下来对工程一些选项进行设置：</p><p>在Project Explorer中，点击工程，右键，然后选择Properties，如下图：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/setting.png?x-oss-process=style/add_shuiying" alt></p><p>首先设置Build Tools Path,在MCU选项中选择Build Tools Path，，如下图：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/set%20build%20tool%20.png?x-oss-process=style/add_shuiying" alt></p><p>点击Browse，选择Build Tools所在目录，在<strong>NucleiStudio_IDE_201908\ToolChain\Build Tools</strong>，即添加<strong>NucleiStudio_IDE_201908\ToolChain\Build Tools\2.10-20180103-1919\bin</strong>。</p><p>然后设置OpenOCD路劲，在<strong>NucleiStudio_IDE_201908\ToolChain\OpenOCD</strong>，即添加<strong>NucleiStudio_IDE_201908\ToolChain\OpenOCD\0.10.0-12-20190722-0746\bin</strong></p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/openocd.png?x-oss-process=style/add_shuiying" alt></p><p>选择ld文件，在C/C++ Build下Setting选项中，具体操作如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/select_ld.png?x-oss-process=style/add_shuiying" alt></p><p>设置完之后，尝试编译，如果没有问题的话，编译成功如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/build_success.png?x-oss-process=style/add_shuiying" alt></p><p>建立的工程默认是控制4个LED的简单程序，我把PA1、PA2、PA3、PA4接上LED，改下代码，如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/change_led.png?x-oss-process=style/add_shuiying" alt></p><p>编译成功后，用USB线把板子通过GD-Link接口连上电脑，点击菜单栏中的RUN，成功运行。</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/Nuclei_Studio/result.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从&lt;a href=&quot;https://mp.weixin.qq.com/s/QgenqNZlTb1T4HTS9brYiQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GD32V——首颗RISC-V内核32位通用MCU&lt;/a&gt;了解到Nuclei Studio
      
    
    </summary>
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/categories/GD32V-RISC-V/"/>
    
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/tags/GD32V-RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>玩转GD32V（二）</title>
    <link href="http:://halin.xyz/%E7%8E%A9%E8%BD%ACGD32V%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http:://halin.xyz/玩转GD32V（二）.html</id>
    <published>2019-09-04T15:05:20.000Z</published>
    <updated>2019-09-04T15:22:07.297Z</updated>
    
    <content type="html"><![CDATA[<p>等了几天终于拿到板子了，拆开来，有一块板子、3条mini USB 数据线，如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/01.jpg?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>板子大概分2部分，上面部分是GD-Link，下面是GD32V103，GD32V103引出了USB，板子上还有个USB转TTL连接到GD32V103的uart。可以看到板子上有3个USB mini接口，分别对应GD-Link，USB转TTL，GD32V103的USB。GD32V103引出的IO部分跟Arduino UNO兼容。</p><p><a href="http://gd32mcu.21ic.com/documents" target="_blank" rel="noopener">http://gd32mcu.21ic.com/documents</a>上可以找到该板子的一些资源:</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/doc.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>下载解压后如下:</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/doc_folder.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt><br>其中有标准库,还分别有GD32V官方DEMO板子的资料,GD32VF103C_START_DEMO_Suites如下:</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/c_start_doc.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt><br><strong>Docs</strong>下有原理图跟GD32VF103C-START评估板用户指南_V1.0(中文版跟英文版)，Projects下是一些例程。</p><p>把板子上的GD-Link通过USB连接到电脑，在Win10上看到是COMSIS-DAP设备：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/dap.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt><br>CMSIS-DAP设备是基于HID协议,一般电脑有自带有驱动,不用另外安装.插入电脑前跟插入电脑后,在设备管理器中的人体学输入设备的下的设备的区别如下:</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/gd_link.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt><br>可以看到插入GD-Link后，多了<strong>HID-compliant device</strong>和<strong>USB 输入设备</strong>。<br>通过查看GD32V的datasheet的boot部分：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/boot_mode.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt><br>跟STM32F103系列一样,GD32V也支持3种启动方式,其中<strong>Boot from system memory</strong>是从内部bootloader启动,该模式可以用通过USB、串口来下载程序,从原理图看到,USB已经通过USB接口引出来了,USART0也通过USB转TTL引出来了,也就是说通过USB连接到板子上的USB或USB转TTL口,然后设置为system memory启动,可以用来下载程序。</p><p>通过查看原理图图,有两个地方需要注意：</p><p>1、板子子只能通过GD-Link的USB接口供电，连接GD32V103的USB的接口和连接USB转TTL的接口没有供电的功能。</p><p>2、如果要通过USB 转TTL使用USART0的发送功能，需要设置下扳子上的JP2条线，把PA9连接到usb转TTL的TX脚，JP2如下图：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/PA9.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;等了几天终于拿到板子了，拆开来，有一块板子、3条mini USB 数据线，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/02/01.jpg?x-oss-process=image/q
      
    
    </summary>
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/categories/GD32V-RISC-V/"/>
    
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/tags/GD32V-RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>玩转GD32V（一）</title>
    <link href="http:://halin.xyz/%E7%8E%A9%E8%BD%ACGD32V%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http:://halin.xyz/玩转GD32V（一）.html</id>
    <published>2019-08-31T16:09:50.000Z</published>
    <updated>2019-09-04T15:18:29.509Z</updated>
    
    <content type="html"><![CDATA[<p>时不时的有看到关于RISC-V的新闻、文章，很多都把RISC-V说的很好，导致我一直想试用下RISC-V内核的芯片，虽然某宝上还是可以找到RISC-V内核的芯片的扳子，不过由于太贵下不了手。在看到GD32V发布的新闻（<a href="https://mp.weixin.qq.com/s/QgenqNZlTb1T4HTS9brYiQ" target="_blank" rel="noopener">GD32V——首颗RISC-V内核32位通用MCU</a>）后（8月22），立马上某宝上搜，发现GD32天猫上已经上架了GD32V的IC，开发板还没上架只是能看到相关海报。还是挺有速度的。</p><p>​    第二天看的时候，发现GD32V开发板已经上架了，可以购买，马上下单买了块GD32VF103C-START（8月23）。可是并没有当天发货，一直等到4天后（8月27）才发货。</p><p>​    还是挺佩服兆易创新，GD32V发布当天就可以下单买芯片，第二天就可以下单买开发板，不过软件跟文档方面就让我心凉了一下，就在发布当天我到官网看了，没找到任何关于GD32V的文档，只在<a href="http://gd32mcu.21ic.com/" target="_blank" rel="noopener">http://gd32mcu.21ic.com/</a>上到到了这个：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/resource.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>下载下来解压发现里面是编译器跟调试器，并不是文档。</p><p>不过距离发布会第四天，已经可以找到些资料了：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/190826.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>可以找到GD32V103的数据手册，用户数手册跟标准固件库了。从网上了解到RT-Thread已经有对GD32V进行支持，到RT-Thread github上看了下，确实可以看到GD32V的BSP。</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/RT-Thread_GD32V.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>查了下，差不多是发布会一个月前创建的BSP：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/first.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>从网上还了解到有好几个IDE支持该芯片：：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/ide.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>可惜的是还没有IAR的,IAR可能会支持RISC-V,也就可能支持GD32V了,keil(MDK)的话,我猜不会支持GD32V,因为keil是属于ARM的,ARM不可能支持自己的对手把。</p><p>下载了Nuclei Studio看了下，是一个基于Eplices的IDE。</p><p>还有Embedded Stduio，下载的是这个版本的：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/EmbeddedStudio.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>试着创建了下工程，确实是可以创建GD32V相关芯片的工程：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/GD32V/em_gd.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt></p><p>现在就等板子到手,试下怎么跑起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时不时的有看到关于RISC-V的新闻、文章，很多都把RISC-V说的很好，导致我一直想试用下RISC-V内核的芯片，虽然某宝上还是可以找到RISC-V内核的芯片的扳子，不过由于太贵下不了手。在看到GD32V发布的新闻（&lt;a href=&quot;https://mp.weixin.q
      
    
    </summary>
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/categories/GD32V-RISC-V/"/>
    
    
      <category term="GD32V RISC-V" scheme="http:://halin.xyz/tags/GD32V-RISC-V/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread下使用SPI驱动SD卡</title>
    <link href="http:://halin.xyz/RT-Thread%E4%B8%8B%E4%BD%BF%E7%94%A8SPI%E9%A9%B1%E5%8A%A8SD%E5%8D%A1.html"/>
    <id>http:://halin.xyz/RT-Thread下使用SPI驱动SD卡.html</id>
    <published>2019-08-21T15:38:10.000Z</published>
    <updated>2019-08-24T15:46:06.065Z</updated>
    
    <content type="html"><![CDATA[<p>突然想起自己有个SD卡模块，可以尝试下在RT-Thread下使用SD卡，模块如下图:<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/SD.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt><br>这个模块是SPI接口，只需MOSI、MISO、SCK、CS，再加上电源就可以使用，跟B-L475E-IOT01A1板子的接法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                |   PB8       CS      |</span><br><span class="line">                |  ---------------&gt;   |</span><br><span class="line">                |   PA5       SCK     |</span><br><span class="line">                |  ---------------&gt;   |</span><br><span class="line">B-L475E-IOT01A1 |   PA6      MISO     |    SD卡模块</span><br><span class="line">(stm32L475VG)   |  &lt;---------------   |</span><br><span class="line">                |   PA7      MOSI     |</span><br><span class="line">                |  ---------------&gt;   |</span><br><span class="line">                |                     |</span><br></pre></td></tr></table></figure><h4 id="配置SPI"><a href="#配置SPI" class="headerlink" title="配置SPI"></a>配置SPI</h4><p>这个SD卡模块需要用到SPI接口，MCU端为主，首先在CubeMX中配置，因为不只需要读数据还需要写数据，所以把SPI配置成Full-Duplex Master,如下图，</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/config_spi.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="config spi"></p><p>然后在ENV工具中输入menuconfig中配置SPI,在下列选项中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hardware Drivers Config</span><br><span class="line">    On-chip Peripheral Drivers</span><br><span class="line">        Enable SPI BUS</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/config_spi_1.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="config spi"></p><h4 id="配置相关驱动"><a href="#配置相关驱动" class="headerlink" title="配置相关驱动"></a>配置相关驱动</h4><p>RT-Thread里面已近有了SPI读写SD卡的驱动，只需在ENV工具中输入menuconfig，然后在如下选项中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RT-Thread Components --&gt;</span><br><span class="line">    Device Drivers  --&gt;</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/config_driver.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="config driver"></p><h4 id="配置文件系统"><a href="#配置文件系统" class="headerlink" title="配置文件系统"></a>配置文件系统</h4><p>由于我的SD卡是FAT32的，在RT-Thread中选择使用Fatfs文件系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RT-Thread Components --&gt;</span><br><span class="line">    Device virtual file system ---&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/config_file_system.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="config file system"></p><h4 id="实现相关代码"><a href="#实现相关代码" class="headerlink" title="实现相关代码"></a>实现相关代码</h4><h5 id="挂载-SPI-从设备到SPI总线设备上-并且注册SD卡设备，如下："><a href="#挂载-SPI-从设备到SPI总线设备上-并且注册SD卡设备，如下：" class="headerlink" title="挂载 SPI 从设备到SPI总线设备上 ,并且注册SD卡设备，如下："></a>挂载 SPI 从设备到SPI总线设备上 ,并且注册SD卡设备，如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int rt_hw_spi1_tfcard(void)</span><br><span class="line">&#123;</span><br><span class="line">    __HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line">    rt_hw_spi_device_attach(&quot;spi1&quot;, &quot;spi11&quot;, GPIOB, GPIO_PIN_8);</span><br><span class="line"></span><br><span class="line">    return msd_init(&quot;sd0&quot;, &quot;spi11&quot;);</span><br><span class="line">&#125;</span><br><span class="line">INIT_DEVICE_EXPORT(rt_hw_spi1_tfcard);</span><br></pre></td></tr></table></figure><h5 id="挂载SD卡"><a href="#挂载SD卡" class="headerlink" title="挂载SD卡"></a>挂载SD卡</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void mount_sdcard_sd0(void *parameter)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i=0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(rt_device_find(&quot;sd0&quot;) != RT_NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            if (dfs_mount(&quot;sd0&quot;, &quot;/&quot;, &quot;elm&quot;, 0, 0) == RT_EOK)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_I(&quot;sd card mount to &apos;/&apos;&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                LOG_W(&quot;sd card mount to &apos;/&apos; failed!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        if(i&gt;5)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_W(&quot;sd card mount to &apos;/&apos; failed!,exit task&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        rt_thread_mdelay(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FINSH_FUNCTION_EXPORT(mount_sdcard_sd0, mount sdcard sd0);</span><br><span class="line">MSH_CMD_EXPORT(mount_sdcard_sd0, mount sdcard sd0);</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/test.gif" alt="test"></p><p>可以成功挂在SD卡，并读取SD卡里面的文件。</p><h4 id="修改Kconfig文件"><a href="#修改Kconfig文件" class="headerlink" title="修改Kconfig文件"></a>修改Kconfig文件</h4><p>驱动测试成功后，修改下Kconfig，在 <strong>board</strong> 目录下的 <strong>Kconfig</strong> 的 <strong>menu “Onboard Peripheral Drivers”</strong>添加如下内容，用CubeMX配置了SPI接口后，在menuconfig中，只需改一个地方，就可以使用SD卡了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config BSP_USING_SDCARD</span><br><span class="line">    bool &quot;Enable SDCARD (spi1)&quot;</span><br><span class="line">    select BSP_USING_SPI</span><br><span class="line">    select BSP_USING_SPI1</span><br><span class="line">    select RT_USING_SPI_MSD</span><br><span class="line">    select RT_USING_DFS</span><br><span class="line">    select RT_USING_DFS_ELMFAT</span><br><span class="line">    default n</span><br></pre></td></tr></table></figure><h4 id="读文件测试，播放Badapple"><a href="#读文件测试，播放Badapple" class="headerlink" title="读文件测试，播放Badapple"></a>读文件测试，播放Badapple</h4><p>参考一位网友的程序<a href="https://github.com/north-sj/OLED-STM32.git" target="_blank" rel="noopener">OLED-STM32</a>，实现在0.96 OLED上播放bad apple代码如下，原理是这位网友把每一帧做成128*64个点，也就1024字节，保存到一个二进制文件中，只要从这个文件中读出1024字节，然后写到oled中，就可以实现播放bad apple了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void bad_apple(void)</span><br><span class="line">&#123;</span><br><span class="line">    int fd, size,i,j=0;</span><br><span class="line">    char buffer[1024];</span><br><span class="line"></span><br><span class="line">    /* 以只读模式打开 /text.txt 文件 */</span><br><span class="line">    fd = open(&quot;/badapple.bin&quot;, O_RDONLY);</span><br><span class="line">    if (fd &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            size = read(fd, buffer, sizeof(buffer));</span><br><span class="line">            if(size &lt;0 ||size ==0)</span><br><span class="line">                break;</span><br><span class="line">            ssd1306_fille(buffer);</span><br><span class="line">            rt_thread_delay(25);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        close(fd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FINSH_FUNCTION_EXPORT(bad_apple, bad apple player);</span><br><span class="line">MSH_CMD_EXPORT(bad_apple, bad apple player);</span><br></pre></td></tr></table></figure><p>完成后的代码在这里：<a href="https://github.com/zhuangzuoyi/Embedded-coding/tree/master/STM32/stm32l475-iot-disco" target="_blank" rel="noopener">stm32l475-iot-disco</a></p><p>这是播放效果：</p><iframe height="498" width="510" src="//player.bilibili.com/player.html?aid=46528329&cid=81504872&page=1" frameborder="0" allowfullscreen><br></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;突然想起自己有个SD卡模块，可以尝试下在RT-Thread下使用SD卡，模块如下图:&lt;br&gt;&lt;img src=&quot;http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/SD.png?x-oss-process=ima
      
    
    </summary>
    
      <category term="STM32 RT-Thread" scheme="http:://halin.xyz/categories/STM32-RT-Thread/"/>
    
    
      <category term="STM32" scheme="http:://halin.xyz/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread下使用SPI驱动0.96寸OLED</title>
    <link href="http:://halin.xyz/RT-Thread%E4%B8%8B%E4%BD%BF%E7%94%A8SPI%E9%A9%B1%E5%8A%A80-96%E5%AF%B8OLED.html"/>
    <id>http:://halin.xyz/RT-Thread下使用SPI驱动0-96寸OLED.html</id>
    <published>2019-08-21T15:36:33.000Z</published>
    <updated>2019-08-24T15:46:07.416Z</updated>
    
    <content type="html"><![CDATA[<p>尝试下在RT-Thread驱动0.96 寸OLED，驱动器是SSD1306，我手上的模块是SPI接口，如下图：<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/spi_oled.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt><br>需要的接口有：VCC GND D0 D1 RST DC CS。<br>其中D0 D1 CS分别是SPI接口的SCK、MOSI、CS，RST是SSD1306复位脚，DC是命令数据选择脚。</p><h3 id="配置SPI总线"><a href="#配置SPI总线" class="headerlink" title="配置SPI总线"></a>配置SPI总线</h3><p>配置之前，存在的设备或总线有：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/before_config_spi.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><p>从上图可以看到只有UART跟PIN设备，接下来开始配置SPI总线。</p><h4 id="CubeMX中配置SPI"><a href="#CubeMX中配置SPI" class="headerlink" title="CubeMX中配置SPI"></a>CubeMX中配置SPI</h4><p>因为新的BSP使用HAL库，需要在CubeMX中初始化SPI，使能SPI，如下图，然后重新生成代码。</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/config_spi.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><h4 id="ENV中配置SPI"><a href="#ENV中配置SPI" class="headerlink" title="ENV中配置SPI"></a>ENV中配置SPI</h4><p>在RT-Thread中使用SPI接口，还需要在ENV工具中输入menuconfig配置SPI，如下图：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/menuconfig_spi.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>配置完，编译并烧录到板子上，看下SPI总线有没有成功创建，执行结果如下图：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/after_config.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><p>可以看出，跟配置之前相比，多了个spi1,</p><h3 id="实现相关代码"><a href="#实现相关代码" class="headerlink" title="实现相关代码"></a>实现相关代码</h3><h4 id="实现相关硬件的初始化"><a href="#实现相关硬件的初始化" class="headerlink" title="实现相关硬件的初始化"></a>实现相关硬件的初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#define SSD1306_DC_PIN  GET_PIN(B, 2)</span><br><span class="line">#define SSD1306_RES_PIN GET_PIN(A, 4)</span><br><span class="line">static struct rt_spi_device *spi_dev_lcd;</span><br><span class="line"></span><br><span class="line">static int rt_hw_ssd1306_config(void)</span><br><span class="line">&#123;</span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    rt_hw_spi_device_attach(&quot;spi1&quot;, &quot;spi10&quot;, GPIOA, GPIO_PIN_15);</span><br><span class="line"></span><br><span class="line">    spi_dev_lcd = (struct rt_spi_device *)rt_device_find(&quot;spi10&quot;);</span><br><span class="line"></span><br><span class="line">    /* config spi */</span><br><span class="line">    &#123;</span><br><span class="line">        struct rt_spi_configuration cfg;</span><br><span class="line">        cfg.data_width = 8;</span><br><span class="line">        cfg.mode = RT_SPI_MASTER | RT_SPI_MODE_3 | RT_SPI_MSB;</span><br><span class="line">        cfg.max_hz = 42 * 1000 * 1000; /* 42M,SPI max 42MHz,lcd 4-wire spi */</span><br><span class="line"></span><br><span class="line">        rt_spi_configure(spi_dev_lcd, &amp;cfg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_pin_mode(SSD1306_DC_PIN, PIN_MODE_OUTPUT);</span><br><span class="line">    rt_pin_mode(SSD1306_RES_PIN, PIN_MODE_OUTPUT);</span><br><span class="line"></span><br><span class="line">    return RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的功能是挂载 SPI 从设备到SPI总线设备上，还初始化了用来驱动OLED的DC、RES所对应管教。</p><h4 id="实现SSD1306的驱动"><a href="#实现SSD1306的驱动" class="headerlink" title="实现SSD1306的驱动"></a>实现SSD1306的驱动</h4><p>然后分别实现SSD1306写数据、写命令函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static rt_err_t ssd1306_write_cmd(const rt_uint8_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    rt_size_t len;</span><br><span class="line"></span><br><span class="line">    rt_pin_write(SSD1306_DC_PIN, PIN_LOW);</span><br><span class="line"></span><br><span class="line">    len = rt_spi_send(spi_dev_lcd, &amp;cmd, 1);</span><br><span class="line"></span><br><span class="line">    if (len != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_I(&quot;ssd1306_write_cmd error. %d&quot;, len);</span><br><span class="line">        return -RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static rt_err_t ssd1306_write_data(const rt_uint8_t data)</span><br><span class="line">&#123;</span><br><span class="line">    rt_size_t len;</span><br><span class="line"></span><br><span class="line">    rt_pin_write(SSD1306_DC_PIN, PIN_HIGH);</span><br><span class="line"></span><br><span class="line">    len = rt_spi_send(spi_dev_lcd, &amp;data, 1);</span><br><span class="line"></span><br><span class="line">    if (len != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_I(&quot;ssd1306_write_data error. %d&quot;, len);</span><br><span class="line">        return -RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return RT_EOK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义个数组，用作SSD1306显示缓存，并实现把缓存写入SSD1306的函数："><a href="#定义个数组，用作SSD1306显示缓存，并实现把缓存写入SSD1306的函数：" class="headerlink" title="定义个数组，用作SSD1306显示缓存，并实现把缓存写入SSD1306的函数："></a>定义个数组，用作SSD1306显示缓存，并实现把缓存写入SSD1306的函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint8_t SSD1306_GRAM[128][8];</span><br><span class="line"></span><br><span class="line">void ssd1306_refresh_gram(void)</span><br><span class="line">&#123;</span><br><span class="line">uint8_t i,n;    </span><br><span class="line">for(i=0;i&lt;8;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">ssd1306_write_cmd (0xb0+i);   </span><br><span class="line">ssd1306_write_cmd (0x00);      </span><br><span class="line">ssd1306_write_cmd (0x10);      </span><br><span class="line">for(n=0;n&lt;128;n++)</span><br><span class="line">            ssd1306_write_data(SSD1306_GRAM[n][i]); </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现请屏幕跟把所有像素都点亮的函数："><a href="#实现请屏幕跟把所有像素都点亮的函数：" class="headerlink" title="实现请屏幕跟把所有像素都点亮的函数："></a>实现请屏幕跟把所有像素都点亮的函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void ssd1306_clear(void)  </span><br><span class="line">&#123;  </span><br><span class="line">uint8_t i,n;  </span><br><span class="line">for(i=0;i&lt;8;i++)for(n=0;n&lt;128;n++)SSD1306_GRAM[n][i]=0X00;  </span><br><span class="line">    ssd1306_refresh_gram();</span><br><span class="line">&#125;</span><br><span class="line">FINSH_FUNCTION_EXPORT(ssd1306_clear, clear ssd136 screan);</span><br><span class="line">MSH_CMD_EXPORT(ssd1306_clear,  clear ssd136 screan);</span><br><span class="line"></span><br><span class="line">void ssd1306_fill(void)  </span><br><span class="line">&#123;  </span><br><span class="line">uint8_t i,n;  </span><br><span class="line">for(i=0;i&lt;8;i++)for(n=0;n&lt;128;n++)SSD1306_GRAM[n][i]=0Xff;  </span><br><span class="line">    ssd1306_refresh_gram();</span><br><span class="line">&#125;</span><br><span class="line">FINSH_FUNCTION_EXPORT(ssd1306_fill, fill ssd136 screan);</span><br><span class="line">MSH_CMD_EXPORT(ssd1306_fill, fill ssd136 screan);</span><br></pre></td></tr></table></figure><h4 id="最后实现SSD1306初始化函数，并把所有像素点亮，测试驱动是不是成功的："><a href="#最后实现SSD1306初始化函数，并把所有像素点亮，测试驱动是不是成功的：" class="headerlink" title="最后实现SSD1306初始化函数，并把所有像素点亮，测试驱动是不是成功的："></a>最后实现SSD1306初始化函数，并把所有像素点亮，测试驱动是不是成功的：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static int rt_hw_ssd1306_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ssd1306_gpio_init();</span><br><span class="line"></span><br><span class="line">    ssd1306_write_cmd(0xAE); </span><br><span class="line">    ssd1306_write_cmd(0xD5); </span><br><span class="line">    ssd1306_write_cmd(80);  </span><br><span class="line">    ssd1306_write_cmd(0xA8);</span><br><span class="line">    ssd1306_write_cmd(0X3F);</span><br><span class="line">    ssd1306_write_cmd(0xD3); </span><br><span class="line">    ssd1306_write_cmd(0X00);</span><br><span class="line"></span><br><span class="line">    ssd1306_write_cmd(0x40); </span><br><span class="line">                                                        </span><br><span class="line">    ssd1306_write_cmd(0x8D); </span><br><span class="line">    ssd1306_write_cmd(0x14); </span><br><span class="line">    ssd1306_write_cmd(0x20); </span><br><span class="line">    ssd1306_write_cmd(0x02); </span><br><span class="line">    ssd1306_write_cmd(0xA1); </span><br><span class="line">    ssd1306_write_cmd(0xC0);</span><br><span class="line">    ssd1306_write_cmd(0xDA); </span><br><span class="line">    ssd1306_write_cmd(0x12); </span><br><span class="line">            </span><br><span class="line">    ssd1306_write_cmd(0x81); </span><br><span class="line">    ssd1306_write_cmd(0xEF);</span><br><span class="line">    ssd1306_write_cmd(0xD9); </span><br><span class="line">    ssd1306_write_cmd(0xf1); </span><br><span class="line">    ssd1306_write_cmd(0xDB); </span><br><span class="line">    ssd1306_write_cmd(0x30); </span><br><span class="line"></span><br><span class="line">    ssd1306_write_cmd(0xA4); </span><br><span class="line">    ssd1306_write_cmd(0xA6); </span><br><span class="line">    ssd1306_write_cmd(0xAF); </span><br><span class="line"></span><br><span class="line">    ssd1306_clear();</span><br><span class="line">    return RT_EOK;</span><br><span class="line">&#125;</span><br><span class="line">INIT_DEVICE_EXPORT(rt_hw_ssd1306_init);</span><br></pre></td></tr></table></figure><h3 id="修改Kconfig文件"><a href="#修改Kconfig文件" class="headerlink" title="修改Kconfig文件"></a>修改Kconfig文件</h3><p>驱动测试成功后，修改下Kconfig，在<strong>board</strong>目录下的 <strong>Kconfig</strong>的 <strong>menu Onboard Peripheral Drivers</strong>添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config BSP_USING_SSD1306</span><br><span class="line"> bool &quot;Enable SSD1306 (spi1)&quot;</span><br><span class="line"> select BSP_USING_SPI</span><br><span class="line"> select BSP_USING_SPI1</span><br><span class="line"> default n</span><br></pre></td></tr></table></figure><p>用CubeMX配置了SPI接口后，在menuconfig中，只需改一个地方，就可以用SPI驱动OLED了。</p><p>参考文档：</p><ol><li><a href="https://www.rt-thread.org/document/site/programming-manual/device/spi/spi/" target="_blank" rel="noopener">SPI设备</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尝试下在RT-Thread驱动0.96 寸OLED，驱动器是SSD1306，我手上的模块是SPI接口，如下图：&lt;br&gt;&lt;img src=&quot;http://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/spi_oled.pn
      
    
    </summary>
    
      <category term="STM32 RT-Thread" scheme="http:://halin.xyz/categories/STM32-RT-Thread/"/>
    
    
      <category term="STM32" scheme="http:://halin.xyz/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>创建RT-Thread下B-L475E-IOT01A1的BSP</title>
    <link href="http:://halin.xyz/%E5%88%9B%E5%BB%BART-Thread%E4%B8%8BB-L475E-IOT01A1%E7%9A%84BSP.html"/>
    <id>http:://halin.xyz/创建RT-Thread下B-L475E-IOT01A1的BSP.html</id>
    <published>2019-08-20T15:07:08.000Z</published>
    <updated>2019-08-25T13:49:44.636Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近RT-Thread重新整理了STM32系列BSP，推出了新的BSP框架，正好手上有一块 <strong><a href="https://www.st.com/en/evaluation-tools/b-l475e-iot01a.html" target="_blank" rel="noopener">B-L475E-IOT01A</a></strong>，可以用来体验下新的BSP。</p><p>​    B-L475E-IOT01A是ST基于STM32L475VG推出的一个面向IOT的DEMO板，具体介绍请查看<a href="https://www.st.com/en/evaluation-tools/b-l475e-iot01a.html" target="_blank" rel="noopener">官网</a>。</p><h3 id="准备环境："><a href="#准备环境：" class="headerlink" title="准备环境："></a>准备环境：</h3><h4 id="1、RT-Thread-Env工具"><a href="#1、RT-Thread-Env工具" class="headerlink" title="1、RT-Thread Env工具"></a>1、RT-Thread Env工具</h4><p>Env官方介绍如：RT-Thread Env工具包括配置器和包管理器，用来对内核和组件的功能进行配置，对组件进行自由裁剪，对线上软件包进行管理，使得系统以搭积木的方式进行构建，简单方便。</p><p>下载地址为：<a href="https://www.rt-thread.org/page/download.html" target="_blank" rel="noopener">https://www.rt-thread.org/page/download.html</a></p><h4 id="2、下载RT-Thread"><a href="#2、下载RT-Thread" class="headerlink" title="2、下载RT-Thread"></a>2、下载RT-Thread</h4><p>直接从RT-Thread github clone下来：</p><blockquote><p>git clone <a href="https://github.com/RT-Thread/rt-thread.git" target="_blank" rel="noopener">https://github.com/RT-Thread/rt-thread.git</a></p></blockquote><h3 id="移植BSP到B-L475E-IOT01A"><a href="#移植BSP到B-L475E-IOT01A" class="headerlink" title="移植BSP到B-L475E-IOT01A"></a>移植BSP到B-L475E-IOT01A</h3><p>​    这里移植步骤是根据<a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/STM32%E7%B3%BB%E5%88%97BSP%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B.md" target="_blank" rel="noopener">STM32 系列 BSP 制作教程</a>来操作的。</p><h4 id="1、使用templates"><a href="#1、使用templates" class="headerlink" title="1、使用templates"></a>1、使用templates</h4><p>首先把<strong>rt-thread\bsp\stm32\libraries\templates</strong> 目录下的 <strong>stm32l4xx</strong>文件夹复制到<strong>rt-thread\bsp\stm32</strong>，并重命名为<strong>stm32l475-iot-disco</strong>。</p><h4 id="2、用CubeMX重新生成项目"><a href="#2、用CubeMX重新生成项目" class="headerlink" title="2、用CubeMX重新生成项目"></a>2、用CubeMX重新生成项目</h4><p>打开<strong>stm32l475-iot-disco\board\CubeMX_Config</strong>下的<strong>CubeMX_Config.ioc</strong>，如下图：</p><p><img src="https://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/open_cubemx_config.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><p>​    由于默认的并不是该板子上的STM32L475VG，需要修改芯片的型号，由于CubeMX不支持重新选择芯片型号，需要新建工程，重新选择芯片型号(点击上图中STM32L475VETX（home旁边）即可重新创建工程)，然后按照教程修改时钟、打开串口、设置下载方式。如下图：</p><p><img src="https://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/config_1.gif" alt="image"></p><p>然后保存并生成项目，<br><img src="https://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/create.gif" alt="image"></p><p>用CubeMX重新生成代码后，拷贝初始化函数，即把<strong>board/CubeMX_Config/Src/main.c</strong>里面的时钟初始化函数<strong>SystemClock_Config</strong>替换<strong>board/board.c</strong>里面的时钟初始化函数<strong>SystemClock_Config</strong>。</p><p>然后按照教程修改Kconfig文件(board/Kconfig)，修改脚本文件，修改工程文件。</p><h4 id="3、根据板子外设修改例程，并编译测试"><a href="#3、根据板子外设修改例程，并编译测试" class="headerlink" title="3、根据板子外设修改例程，并编译测试"></a>3、根据板子外设修改例程，并编译测试</h4><p><strong>applications</strong>下面的<strong>mian.c</strong>中有个控制等闪烁的例子，该板子LED部分原理如下：</p><p><img src="https://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/led.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><p>这里选择使用LED2，通过查看原理图，LED2是连接到了PB14，把控制led的IO改为PB14，并加上一条语句，输出<strong>hello This is the BSP for B-L475E-IOT01A(STM32L475VG)</strong>，代码修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define LED0_PIN    GET_PIN(B, 14)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 1;</span><br><span class="line">    /* set LED0 pin mode to output */</span><br><span class="line">    rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT);</span><br><span class="line">    rt_kprintf(&quot;\r\nHello This is the BSP for B-L475E-IOT01A(STM32L475VG)\r\n&quot;);</span><br><span class="line">    while (count++)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_pin_write(LED0_PIN, PIN_HIGH);</span><br><span class="line">        rt_thread_mdelay(500);</span><br><span class="line">        rt_pin_write(LED0_PIN, PIN_LOW);</span><br><span class="line">        rt_thread_mdelay(500);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用RT-Thread Env工具编译工程，把固件下载到板子上，运行如下：</p><p><img src="https://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/test_bsp.gif" alt="image"></p><h3 id="填的坑"><a href="#填的坑" class="headerlink" title="填的坑"></a>填的坑</h3><ol><li>该板子有带USB CDC（usb转串口）设备的ST-LINK，并接到了STM32L475VG的Uart1,如下图，因此，可以不用其他的串口设备，可以直接使用这个ST-LINK上的CDC设备实现STM32L475通过串口跟PC连接，来查看调试信息，</li></ol><p><img src="https://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/CDC.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><p>一开始不管我怎么调，都没有调试信息出来，确认了原理图是UART1，又确认了代码是UART1，最后仔细查看了原理图，发现MCU部分UART1是使用了PB6跟PB7，如下图：</p><p><img src="https://halin.oss-cn-shanghai.aliyuncs.com/B-L475E-IOT01A/uart1.png?x-oss-process=image/quality,q_90/watermark,text_SGFsaW4,color_e2132c,size_40,g_ne,t_69,x_10,y_10" alt="image"></p><p>所以，CubeMX中配置UART1的时候需要把UART的RX、TX重映射到PB6、PB7。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    最近RT-Thread重新整理了STM32系列BSP，推出了新的BSP框架，正好手上有一块 &lt;strong&gt;&lt;a href=&quot;https://www.st.com/en/evaluation-tools/b-l475e-iot01a.html&quot; target=&quot;_
      
    
    </summary>
    
      <category term="STM32 RT-Thread" scheme="http:://halin.xyz/categories/STM32-RT-Thread/"/>
    
    
      <category term="STM32" scheme="http:://halin.xyz/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>表情包世界读卡器</title>
    <link href="http:://halin.xyz/bqbsjduq.html"/>
    <id>http:://halin.xyz/bqbsjduq.html</id>
    <published>2019-05-24T14:59:43.000Z</published>
    <updated>2019-08-08T15:25:58.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>有一类表情包很流行，(这里应该有配图，不过，怕侵权，没了解过这些表情包图片能不能用在个人文章中)这类表情包都会有这么一个格式的文字：滴，XXX卡，有一天，突然想到，可以做个类似的东西玩玩。  </p><p>硬件方面，语音模块首先想到的是<a href="https://baike.baidu.com/item/TTS/3512737" target="_blank" rel="noopener">TTS</a>模块，这类模块应该是很成熟，某宝上很多，使用起来也很简单，直接把想播放的语音的文字通过串口发送到这里模块就行了。 </p><p>后来想起来手上有一块ESP32Lyrat音频开发板，也许可以用，就不用再买TTS模块（舍不得钱），看了下乐鑫提供的<a href="https://github.com/espressif/esp-adf" target="_blank" rel="noopener">音频开发框架（adf）</a>中有播放mp3的例程，只要做出相应语言的mp3文件就行了，<br>因为我用过阿里云，知道阿里云有提供tts服务，实验了下，可以用阿里云的tts服务来生成mp3文件。<br>读卡模块，首先想到的是手上有的RC522模块，手上的RC522模块是spi接口的，不过，esp32 lytea板子可用的IO太少了，最后选用了可以用串口通讯的PN532模块，<br>总体思路是程序中先保存几个卡片的UID，然后把PN532读取卡片的UID跟已近保存到程序中的UID比较，如果读取到的卡片的UID存在程序中的UID则返回一个参数，然后根据这个参数播放不同的mp3文件。原理上很简单。</p><h1 id="2-硬件"><a href="#2-硬件" class="headerlink" title="2.硬件"></a>2.硬件</h1><ul><li><p>读卡模块：PN532 NFC 模块<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/bqbsjduq/PN532.jpg" alt="image"></p></li><li><p>ESP32开发板：ESP32-LyraT 4.2<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/bqbsjduq/lyrat.jpg" alt="image"></p></li></ul><h1 id="3-开发环境-windown7"><a href="#3-开发环境-windown7" class="headerlink" title="3.开发环境:windown7"></a>3.开发环境:windown7</h1><ol><li><p>编译器<br>参考：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/get-started/windows-setup.html" target="_blank" rel="noopener">https://docs.espressif.com/projects/esp-idf/zh_CN/stable/get-started/windows-setup.html</a></p><p> 下载esp32_win32_msys2_environment_and_toolchain，解压即可，</p></li><li>SDK<br>下载音频开发框架（adf）:参考：<a href="https://github.com/espressif/esp-adf" target="_blank" rel="noopener">https://github.com/espressif/esp-adf</a><blockquote><p>git clone –recursive <a href="https://github.com/espressif/esp-adf.git" target="_blank" rel="noopener">https://github.com/espressif/esp-adf.git</a></p></blockquote></li></ol><h1 id="4-使用adf中的工程"><a href="#4-使用adf中的工程" class="headerlink" title="4.使用adf中的工程"></a>4.使用adf中的工程</h1><p>这里使用esp-adf/examples/player/pipeline_sdcard_mp3工程,打开编译工具，进入到该目录，输入命令<strong>make menuconfig</strong>进行配置，这里主要配置如下几项：</p><p>1、选择相应的板子的型号，我这里是ESP32-LyraT 4.2，配置入下：<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/bqbsjduq/board.PNG" alt></p><p>2、然后设置串口、Flash参数，如下图：<br><img src="http://halin.oss-cn-shanghai.aliyuncs.com/bqbsjduq/port.PNG" alt></p><p>配置完之后，使用命令<strong>make flash</strong>进行烧录，默认的工程是播放SD卡中的<strong>test.mp3</strong>文件，把有<strong>test.mp3</strong>文件的SD卡插入板子上的SD卡卡座，重新开机，就可以播放音乐了</p><h1 id="5-使用阿里云TTS服务生成MP3文件"><a href="#5-使用阿里云TTS服务生成MP3文件" class="headerlink" title="5.使用阿里云TTS服务生成MP3文件"></a>5.使用阿里云TTS服务生成MP3文件</h1><p>1、TTS在阿里云里面，是<a href="https://ai.aliyun.com/nls" target="_blank" rel="noopener">智能语音交互</a>中的<a href="https://ai.aliyun.com/nls/tts?spm=5176.12061031.1228726.4.44883cb4tPtjyl" target="_blank" rel="noopener">语音合成</a>的功能，里面的描述是：语音合成服务，通过先进的深度学习技术，将文本转换成自然流畅的语音。文本转换成语音就是TTS。要使用该服务，首先需要个阿里云账号，然后开通该服务并创建一个项目，完成后，在控制台中可以找到<strong>AccessToken</strong>跟项目<strong>Appkey</strong>。如下图，这两个参数在生成mp3文件时需要用到。</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/bqbsjduq/aliyun_tts.png" alt></p><p>2、阿里云提供的语音合成的RESTful API 有两个（详情查看<a href="https://help.aliyun.com/document_detail/94737.html?spm=a2c4g.11186623.6.593.68b25275DRasFX" target="_blank" rel="noopener">文档</a>）,我使用了其中的get方法，该方法的url格式为：</p><blockquote><p><a href="https://nls-gateway.cn-shanghai.aliyuncs.com/stream/v1/tts?appkey=${您的appkey}&amp;token=${您的token}&amp;text=${想要合成的文本}&amp;format=mp3&amp;sample_rate=16000" target="_blank" rel="noopener">https://nls-gateway.cn-shanghai.aliyuncs.com/stream/v1/tts?appkey=${您的appkey}&amp;token=${您的token}&amp;text=${想要合成的文本}&amp;format=mp3&amp;sample_rate=16000</a></p></blockquote><p>把上面的${您的appkey}、${您的token}、${想要合成的文本}替换成你的就可以了，我一开始使用用chrome一个http调试插件来生成文件的，后来发现了个更简单的方法，就是直接用浏览器打开该URL，然后可以播放该音频，如果满足效果的话，另存为即可，既可以验证也可以下载，一举两得。</p><h1 id="6-PN532驱动"><a href="#6-PN532驱动" class="headerlink" title="6.PN532驱动"></a>6.PN532驱动</h1><p>由于这里只需要读取卡片的UID，所以只需用到PN532两个命令（不包括唤醒命令）：</p><ol><li><p>设置卡片为读卡器模式，并且是读14443的卡（因为我手上的是M1卡）</p><blockquote><p>0x00,0xff,0x03,0xfd,0xd4,0x14,0x01,0x17,x00</p></blockquote></li><li><p>然后是寻卡指令，可以获得卡片的UID</p><blockquote><p>0x00,0xff,0x04,0xfc,0xd4,0x4a,0x02,0x00,0xe0,0x00</p></blockquote></li></ol><h1 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h1><p>整个做下了也还是很简单的，自己写的代码主要是PN532的驱动，播放音频部分乐鑫已近做了只要拿来用就行，全部代码及音频文件都在<a href="https://github.com/zhuangzuoyi/Embedded-coding/tree/master/esp32/meme_reader" target="_blank" rel="noopener">meme_reader</a></p><p>这是最后的效果：</p><iframe height="498" width="510" src="//player.bilibili.com/player.html?aid=53503067&cid=93599298&page=1" frameborder="0" allowfullscreen><br></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;有一类表情包很流行，(这里应该有配图，不过，怕侵权，没了解过这些表情包图片能不能用在个人文章中)这类表情包都会有这么一个格式
      
    
    </summary>
    
      <category term="ESP32 NFC" scheme="http:://halin.xyz/categories/ESP32-NFC/"/>
    
    
      <category term="ESP32" scheme="http:://halin.xyz/tags/ESP32/"/>
    
  </entry>
  
  <entry>
    <title>显示电脑中的串口及串口详细信息</title>
    <link href="http:://halin.xyz/%E6%98%BE%E7%A4%BA%E4%B8%B2%E5%8F%A3.html"/>
    <id>http:://halin.xyz/显示串口.html</id>
    <published>2019-05-20T14:48:22.000Z</published>
    <updated>2019-05-20T15:15:30.472Z</updated>
    
    <content type="html"><![CDATA[<p>一个简单的不能再简单工具，把头文件包含进去也才14行代码，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QtSerialPort/QSerialPortInfo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QtDebug"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> infos = QSerialPortInfo::availablePorts();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> QSerialPortInfo &amp;info : infos) &#123;</span><br><span class="line">        QString menu_temp = info.portName() + <span class="string">" : "</span> + info.description();</span><br><span class="line">        qDebug() &lt;&lt; menu_temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序只能在命令行中打开，是用来显示电脑中串口的详细信息，因为工作学习中经常要使用到串口，几乎每次使用要打开设备管理器查看用的是哪个串口，有时候打开会很慢，要等上几秒钟，还有使用设备管理器查看串口设备需要如下步骤：<br>1、打开计算机管理<br>2、选择设备管理器<br>3、从众多硬件中找到串口</p><p>很浪费时间，于是，我就想着写了这个软件，把该软件的目录添加到环境变量，就可以在命令行中打开，如下，win 7  cmd中：</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/QT/showserial/cmd.png" alt="cmd"></p><p>还有在VScode中的执行结果如下；</p><p><img src="http://halin.oss-cn-shanghai.aliyuncs.com/QT/showserial/vscode.png" alt="vscode"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个简单的不能再简单工具，把头文件包含进去也才14行代码，如下&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="QT" scheme="http:://halin.xyz/categories/QT/"/>
    
    
      <category term="QT" scheme="http:://halin.xyz/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>重新开始使用hexo</title>
    <link href="http:://halin.xyz/hello-world.html"/>
    <id>http:://halin.xyz/hello-world.html</id>
    <published>2019-04-20T09:41:03.887Z</published>
    <updated>2019-05-19T09:14:42.988Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前就尝试过用hexo来搭建博客，不过由于当时懂的还太少（github、web等），没有弄出来，后来为了学前端，尝试了一点一点的把博客敲出来（除了博客内容还有html、CSS等），随着web方面的入门，还有我做的博客中web方面的知识也就那些，再继续这样做下去的话，就是在浪费时间，所以，又决定使用hexo来搭建博客。</p><p>由于没有时间把之前的博客迁移过来，只好在这里列出来，博客首页是：<a href="http://zhuangzuoyi.github.io/blog" target="_blank" rel="noopener">http://zhuangzuoyi.github.io/blog</a><br>1、<a href="http://zhuangzuoyi.github.io/blog/article/esp8266/esp8266_user_define_smartconfig/esp8266_user_define_smartconfig.html" target="_blank" rel="noopener">自定义ESP8266 SmartConfig</a><br>2、<a href="http://zhuangzuoyi.github.io/blog/article/python/bookmarks/bookmarts.html" target="_blank" rel="noopener">Chrome bookmarts to web</a><br>3、<a href="http://zhuangzuoyi.github.io/blog/article/project/BT05_IOT/bt05_iot.html" target="_blank" rel="noopener">BT05 IOT</a><br>4、<a href="http://zhuangzuoyi.github.io/blog/article/python/spider_for_tumblr/simple_spider_for_tumblr.html" target="_blank" rel="noopener">a simple spider for tumblr</a><br>5、<a href="http://zhuangzuoyi.github.io/blog/article/log/Finger_piano/Finger_piano.html" target="_blank" rel="noopener">电动手敲琴</a><br>6、<a href="http://zhuangzuoyi.github.io/blog/article/STM32/01.html" target="_blank" rel="noopener">使用串口唤醒处于停止模式的STM32</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久之前就尝试过用hexo来搭建博客，不过由于当时懂的还太少（github、web等），没有弄出来，后来为了学前端，尝试了一点一点的把博客敲出来（除了博客内容还有html、CSS等），随着web方面的入门，还有我做的博客中web方面的知识也就那些，再继续这样做下去的话，就是
      
    
    </summary>
    
      <category term="blog" scheme="http:://halin.xyz/categories/blog/"/>
    
    
      <category term="博客，文章" scheme="http:://halin.xyz/tags/%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
